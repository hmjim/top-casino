<?php// класс, который собирает всю структуру комментовclass clean_comments_constructor extends Walker_Comment {	public function start_lvl( &$output, $depth = 0, $args = array()) { // что выводим перед дочерними комментариями		$output .= '<ul class="children">' . "\n";	}	public function end_lvl( &$output, $depth = 0, $args = array()) { // что выводим после дочерних комментариев		$output .= "</ul><!-- .children -->\n";	}	protected function comment( $comment, $depth, $args ) { // разметка каждого комментария, без закрывающего </li>!		$classes = implode(' ', get_comment_class()).($comment->comment_author_email == get_the_author_meta('email') ? ' author-comment' : ''); // берем стандартные классы комментария и если коммент пренадлежит автору поста добавляем класс author-comment		echo '<li id="li-comment-'.get_comment_ID().'" class="'.$classes.'">'."\n"; // родительский тэг комментария с классами выше и уникальным id		echo '<div class="single-comment" id="comment-'.get_comment_ID().'">'."\n"; // элемент с таким id нужен для якорных ссылок на коммент		if ( '0' == $comment->comment_approved ) echo '<em class="comment-awaiting-moderation">Ваш комментарий будет опубликован после проверки модератором.</em>'."\n"; // если комментарий должен пройти проверку		echo '<div class="row">';		echo '<div class="col-xs-3 col-md-1">';		echo '<div class="avatar"><img src="'.get_stylesheet_directory_uri().'/assets/img/avatar.png"></div>';		echo '<div class="date">'.get_comment_date('j F Y').'</div>';		echo "</div>";		echo '<div class="col-xs-9 col-md-11">';		echo '<div class="author">'.get_comment_author().'</div>';		echo '<div class="comment_text">'.comment_text().'</div>';		$reply_link_args = array( // опции ссылки "ответить"			'depth' => $depth, // текущая вложенность			'reply_text' => 'Ответить на сообщение', // текст			'login_text' => 'Вы должны быть залогинены' // текст если юзер должен залогинеться		);		echo get_comment_reply_link(array_merge($args, $reply_link_args)); // выводим ссылку ответить		echo '</div>';		echo '</div>';		echo '</div>'."\n"; // закрываем див	}	public function end_el( &$output, $comment, $depth = 0, $args = array() ) { // конец каждого коммента		$output .= "</li><!-- #comment-## -->\n";	}}/** * Обрезка текста (excerpt). Шоткоды вырезаются. Минимальное значение maxchar может быть 22. * * @param (строка/массив) $args Параметры. * * @return HTML * ver 2.6.1 */function kama_excerpt( $args = '' ){	global $post;	$default = array(		'maxchar'   => 350,   // количество символов.		'text'      => '',    // какой текст обрезать (по умолчанию post_excerpt, если нет post_content.		// Если есть тег <!--more-->, то maxchar игнорируется и берется все до <!--more--> вместе с HTML		'autop'     => true,  // Заменить переносы строк на <p> и <br> или нет		'save_tags' => '',    // Теги, которые нужно оставить в тексте, например '<strong><b><a>'		'more_text' => 'Читать дальше...', // текст ссылки читать дальше	);	if( is_array($args) ) $_args = $args;	else                  parse_str( $args, $_args );	$rg = (object) array_merge( $default, $_args );	if( ! $rg->text ) $rg->text = $post->post_excerpt ?: $post->post_content;	$rg = apply_filters('kama_excerpt_args', $rg );	$text = $rg->text;	$text = preg_replace ('~\[/?.*?\](?!\()~', '', $text ); // убираем шоткоды, например:[singlepic id=3], markdown +	$text = trim( $text );	// <!--more-->	if( strpos( $text, '<!--more-->') ){		preg_match('/(.*)<!--more-->/s', $text, $mm );		$text = trim($mm[1]);		$text_append = ' <a href="'. get_permalink( $post->ID ) .'#more-'. $post->ID .'">'. $rg->more_text .'</a>';	}	// text, excerpt, content	else {		$text = trim( strip_tags($text, $rg->save_tags) );		// Обрезаем		if( mb_strlen($text) > $rg->maxchar ){			$text = mb_substr( $text, 0, $rg->maxchar );			$text = preg_replace('~(.*)\s[^\s]*$~s', '\\1 ...', $text ); // убираем последнее слово, оно 99% неполное		}	}	// Сохраняем переносы строк. Упрощенный аналог wpautop()	if( $rg->autop ){		$text = preg_replace(			array("~\r~", "~\n{2,}~", "~\n~",   '~</p><br ?/>~'),			array('',     '</p><p>',  '<br />', '</p>'),			$text		);	}	$text = apply_filters('kama_excerpt', $text, $rg );	if( isset($text_append) ) $text .= $text_append;	return ($rg->autop && $text) ? "<p>$text</p>" : $text;}/* Подсчет количества посещений страниц---------------------------------------------------------- */add_action('wp_head', 'kama_postviews');function kama_postviews() {	/* ------------ Настройки -------------- */	$meta_key       = 'views';  // Ключ мета поля, куда будет записываться количество просмотров.	$who_count      = 0;            // Чьи посещения считать? 0 - Всех. 1 - Только гостей. 2 - Только зарегистрированных пользователей.	$exclude_bots   = 1;            // Исключить ботов, роботов, пауков и прочую нечесть :)? 0 - нет, пусть тоже считаются. 1 - да, исключить из подсчета.	global $user_ID, $post;	if(is_singular()) {		$id = (int)$post->ID;		static $post_views = false;		if($post_views) return true; // чтобы 1 раз за поток		$post_views = (int)get_post_meta($id,$meta_key, true);		$should_count = false;		switch( (int)$who_count ) {			case 0: $should_count = true;				break;			case 1:				if( (int)$user_ID == 0 )					$should_count = true;				break;			case 2:				if( (int)$user_ID > 0 )					$should_count = true;				break;		}		if( (int)$exclude_bots==1 && $should_count ){			$useragent = $_SERVER['HTTP_USER_AGENT'];			$notbot = "Mozilla|Opera"; //Chrome|Safari|Firefox|Netscape - все равны Mozilla			$bot = "Bot/|robot|Slurp/|yahoo"; //Яндекс иногда как Mozilla представляется			if ( !preg_match("/$notbot/i", $useragent) || preg_match("!$bot!i", $useragent) )				$should_count = false;		}		if($should_count)			if( !update_post_meta($id, $meta_key, ($post_views+1)) ) add_post_meta($id, $meta_key, 1, true);	}	return true;}/** * Хлебные крошки для WordPress (breadcrumbs) * * @param  string [$sep  = '']      Разделитель. По умолчанию ' » ' * @param  array  [$l10n = array()] Для локализации. См. переменную $default_l10n. * @param  array  [$args = array()] Опции. См. переменную $def_args * @return string Выводит на экран HTML код * * version 3.3.2 */function kama_breadcrumbs( $sep = ' » ', $l10n = array(), $args = array() ){  $kb = new Kama_Breadcrumbs;  echo $kb->get_crumbs( $sep, $l10n, $args );}class Kama_Breadcrumbs {  public $arg;  // Локализация  static $l10n = array(    'home'       => 'Главная',    'paged'      => 'Страница %d',    '_404'       => 'Ошибка 404',    'search'     => 'Результаты поиска по запросу - <b>%s</b>',    'author'     => 'Архив автора: <b>%s</b>',    'year'       => 'Архив за <b>%d</b> год',    'month'      => 'Архив за: <b>%s</b>',    'day'        => '',    'attachment' => 'Медиа: %s',    'tag'        => 'Записи по метке: <b>%s</b>',    'tax_tag'    => '%1$s из "%2$s" по тегу: <b>%3$s</b>',    // tax_tag выведет: 'тип_записи из "название_таксы" по тегу: имя_термина'.    // Если нужны отдельные холдеры, например только имя термина, пишем так: 'записи по тегу: %3$s'  );  // Параметры по умолчанию  static $args = array(    'on_front_page'   => true,  // выводить крошки на главной странице    'show_post_title' => true,  // показывать ли название записи в конце (последний элемент). Для записей, страниц, вложений    'show_term_title' => true,  // показывать ли название элемента таксономии в конце (последний элемент). Для меток, рубрик и других такс    'title_patt'      => '<span class="kb_title">%s</span>', // шаблон для последнего заголовка. Если включено: show_post_title или show_term_title    'last_sep'        => true,  // показывать последний разделитель, когда заголовок в конце не отображается    'markup'          => 'schema.org', // 'markup' - микроразметка. Может быть: 'rdf.data-vocabulary.org', 'schema.org', '' - без микроразметки                       // или можно указать свой массив разметки:                       // array( 'wrappatt'=>'<div class="kama_breadcrumbs">%s</div>', 'linkpatt'=>'<a href="%s">%s</a>', 'sep_after'=>'', )    'priority_tax'    => array('category'), // приоритетные таксономии, нужно когда запись в нескольких таксах    'priority_terms'  => array(), // 'priority_terms' - приоритетные элементы таксономий, когда запись находится в нескольких элементах одной таксы одновременно.                    // Например: array( 'category'=>array(45,'term_name'), 'tax_name'=>array(1,2,'name') )                    // 'category' - такса для которой указываются приор. элементы: 45 - ID термина и 'term_name' - ярлык.                    // порядок 45 и 'term_name' имеет значение: чем раньше тем важнее. Все указанные термины важнее неуказанных...    'nofollow' => false, // добавлять rel=nofollow к ссылкам?    // служебные    'sep'             => '',    'linkpatt'        => '',    'pg_end'          => '',  );  function get_crumbs( $sep, $l10n, $args ){    global $post, $wp_query, $wp_post_types;    self::$args['sep'] = $sep;    // Фильтрует дефолты и сливает    $loc = (object) array_merge( apply_filters('kama_breadcrumbs_default_loc', self::$l10n ), $l10n );    $arg = (object) array_merge( apply_filters('kama_breadcrumbs_default_args', self::$args ), $args );    $arg->sep = '<span class="kb_sep">'. $arg->sep .'</span>'; // дополним    // упростим    $sep = & $arg->sep;    $this->arg = & $arg;    // микроразметка ---    if(1){      $mark = & $arg->markup;      // Разметка по умолчанию      if( ! $mark ) $mark = array(        'wrappatt'  => '<div class="kama_breadcrumbs">%s</div>',        'linkpatt'  => '<a href="%s">%s</a>',        'sep_after' => '',      );      // rdf      elseif( $mark === 'rdf.data-vocabulary.org' ) $mark = array(        'wrappatt'   => '<div class="kama_breadcrumbs" prefix="v: http://rdf.data-vocabulary.org/#">%s</div>',        'linkpatt'   => '<span typeof="v:Breadcrumb"><a href="%s" rel="v:url" property="v:title">%s</a>',        'sep_after'  => '</span>', // закрываем span после разделителя!      );      // schema.org      elseif( $mark === 'schema.org' ) $mark = array(        'wrappatt'   => '<div class="kama_breadcrumbs" itemscope itemtype="http://schema.org/BreadcrumbList">%s</div>',        'linkpatt'   => '<span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem"><a href="%s" itemprop="item"><span itemprop="name">%s</span><meta itemprop="position" content="$d"></a></span>',        'sep_after'  => '',      );      elseif( ! is_array($mark) )        die( __CLASS__ .': "markup" parameter must be array...');      $wrappatt  = $mark['wrappatt'];      $arg->linkpatt  = $arg->nofollow ? str_replace('<a ','<a rel="nofollow"', $mark['linkpatt']) : $mark['linkpatt'];      $arg->sep      .= $mark['sep_after']."\n";    }    $linkpatt = $arg->linkpatt; // упростим    $q_obj = get_queried_object();    // может это архив пустой таксы?    $ptype = null;    if( empty($post) ){      if( isset($q_obj->taxonomy) )        $ptype = & $wp_post_types[ get_taxonomy($q_obj->taxonomy)->object_type[0] ];    }    else $ptype = & $wp_post_types[ $post->post_type ];    // paged    $arg->pg_end = '';    if( ($paged_num = get_query_var('paged')) || ($paged_num = get_query_var('page')) )      $arg->pg_end = $sep . sprintf( $loc->paged, (int) $paged_num );    $pg_end = $arg->pg_end; // упростим    // ну, с богом...    $out = '';    if( is_front_page() ){      return $arg->on_front_page ? sprintf( $wrappatt, ( $paged_num ? sprintf($linkpatt, get_home_url(), $loc->home) . $pg_end : $loc->home ) ) : '';    }    // страница записей, когда для главной установлена отдельная страница.    elseif( is_home() ) {      $out = $paged_num ? ( sprintf( $linkpatt, get_permalink($q_obj), esc_html($q_obj->post_title) ) . $pg_end ) : esc_html($q_obj->post_title);    }    elseif( is_404() ){      $out = $loc->_404;    }    elseif( is_search() ){      $out = sprintf( $loc->search, esc_html( $GLOBALS['s'] ) );    }    elseif( is_author() ){      $tit = sprintf( $loc->author, esc_html($q_obj->display_name) );      $out = ( $paged_num ? sprintf( $linkpatt, get_author_posts_url( $q_obj->ID, $q_obj->user_nicename ) . $pg_end, $tit ) : $tit );    }    elseif( is_year() || is_month() || is_day() ){      $y_url  = get_year_link( $year = get_the_time('Y') );      if( is_year() ){        $tit = sprintf( $loc->year, $year );        $out = ( $paged_num ? sprintf($linkpatt, $y_url, $tit) . $pg_end : $tit );      }      // month day      else {        $y_link = sprintf( $linkpatt, $y_url, $year);        $m_url  = get_month_link( $year, get_the_time('m') );        if( is_month() ){          $tit = sprintf( $loc->month, get_the_time('F') );          $out = $y_link . $sep . ( $paged_num ? sprintf( $linkpatt, $m_url, $tit ) . $pg_end : $tit );        }        elseif( is_day() ){          $m_link = sprintf( $linkpatt, $m_url, get_the_time('F'));          $out = $y_link . $sep . $m_link . $sep . get_the_time('l');        }      }    }    // Древовидные записи    elseif( is_singular() && $ptype->hierarchical ){      $out = $this->_add_title( $this->_page_crumbs($post), $post );    }    // Таксы, плоские записи и вложения    else {           $term = $q_obj; // таксономии      // определяем термин для записей (включая вложения attachments)      if( is_singular() ){        // изменим $post, чтобы определить термин родителя вложения        if( is_attachment() && $post->post_parent ){          $save_post = $post; // сохраним          $post = get_post($post->post_parent);        }        // учитывает если вложения прикрепляются к таксам древовидным - все бывает :)        $taxonomies = get_object_taxonomies( $post->post_type );        // оставим только древовидные и публичные, мало ли...        $taxonomies = array_intersect( $taxonomies, get_taxonomies( array('hierarchical' => true, 'public' => true) ) );        if( $taxonomies ){          // сортируем по приоритету          if( ! empty($arg->priority_tax) ){            usort( $taxonomies, function($a,$b)use($arg){              $a_index = array_search($a, $arg->priority_tax);              if( $a_index === false ) $a_index = 9999999;              $b_index = array_search($b, $arg->priority_tax);              if( $b_index === false ) $b_index = 9999999;              return ( $b_index === $a_index ) ? 0 : ( $b_index < $a_index ? 1 : -1 ); // меньше индекс - выше            } );          }          // пробуем получить термины, в порядке приоритета такс          foreach( $taxonomies as $taxname ){            if( $terms = get_the_terms( $post->ID, $taxname ) ){              // проверим приоритетные термины для таксы              $prior_terms = & $arg->priority_terms[ $taxname ];              if( $prior_terms && count($terms) > 2 ){                foreach( (array) $prior_terms as $term_id ){                  $filter_field = is_numeric($term_id) ? 'term_id' : 'slug';                  $_terms = wp_list_filter( $terms, array($filter_field=>$term_id) );                  if( $_terms ){                    $term = array_shift( $_terms );                    break;                  }                }              }              else                $term = array_shift( $terms );              break;            }          }        }        if( isset($save_post) ) $post = $save_post; // вернем обратно (для вложений)      }      // вывод      // все виды записей с терминами или термины      if( $term && isset($term->term_id) ){        $term = apply_filters('kama_breadcrumbs_term', $term );        // attachment        if( is_attachment() ){          if( ! $post->post_parent )            $out = sprintf( $loc->attachment, esc_html($post->post_title) );          else {            if( ! $out = apply_filters('attachment_tax_crumbs', '', $term, $this ) ){              $_crumbs    = $this->_tax_crumbs( $term, 'self' );              $parent_tit = sprintf( $linkpatt, get_permalink($post->post_parent), get_the_title($post->post_parent) );              $_out = implode( $sep, array($_crumbs, $parent_tit) );              $out = $this->_add_title( $_out, $post );            }          }        }        // single        elseif( is_single() ){                   if( ! $out = apply_filters('post_tax_crumbs', '', $term, $this ) ){            $_crumbs = $this->_tax_crumbs( $term, 'self' );            $out = $this->_add_title( $_crumbs, $post );          }        }        // не древовидная такса (метки)        elseif( ! is_taxonomy_hierarchical($term->taxonomy) ){          // метка          if( is_tag() )            $out = $this->_add_title('', $term, sprintf( $loc->tag, esc_html($term->name) ) );          // такса          elseif( is_tax() ){            $post_label = $ptype->labels->name;            $tax_label = $GLOBALS['wp_taxonomies'][ $term->taxonomy ]->labels->name;            $out = $this->_add_title('', $term, sprintf( $loc->tax_tag, $post_label, $tax_label, esc_html($term->name) ) );          }        }        // древовидная такса (рибрики)        else {          if( ! $out = apply_filters('term_tax_crumbs', '', $term, $this ) ){            $_crumbs = $this->_tax_crumbs( $term, 'parent' );            $out = $this->_add_title( $_crumbs, $term, esc_html($term->name) );                               }        }      }      // влоежния от записи без терминов      elseif( is_attachment() ){        $parent = get_post($post->post_parent);        $parent_link = sprintf( $linkpatt, get_permalink($parent), esc_html($parent->post_title) );        $_out = $parent_link;        // вложение от записи древовидного типа записи        if( is_post_type_hierarchical($parent->post_type) ){          $parent_crumbs = $this->_page_crumbs($parent);          $_out = implode( $sep, array( $parent_crumbs, $parent_link ) );        }        $out = $this->_add_title( $_out, $post );      }      // записи без терминов      elseif( is_singular() ){        $out = $this->_add_title( '', $post );      }    }    // замена ссылки на архивную страницу для типа записи    $home_after = apply_filters('kama_breadcrumbs_home_after', '', $linkpatt, $sep, $ptype );    if( '' === $home_after ){      // Ссылка на архивную страницу типа записи для: отдельных страниц этого типа; архивов этого типа; таксономий связанных с этим типом.      if( $ptype && $ptype->has_archive && ! in_array( $ptype->name, array('post','page','attachment') )        && ( is_post_type_archive() || is_singular() || (is_tax() && in_array($term->taxonomy, $ptype->taxonomies)) )      ){        $pt_title = $ptype->labels->name;        // первая страница архива типа записи        if( is_post_type_archive() && ! $paged_num )          $home_after = sprintf( $this->arg->title_patt, $pt_title );        // singular, paged post_type_archive, tax        else{                    //$posioo = 1;          $home_after = sprintf( $linkpatt, get_post_type_archive_link($ptype->name), $pt_title, $posioo-- );          $home_after .= ( ($paged_num && ! is_tax()) ? $pg_end : $sep ); // пагинация        }      }    }    $before_out = sprintf( $linkpatt, home_url(), $loc->home , $posioo--) . ( $home_after ? $sep.$home_after : ($out ? $sep : '') );    $out = apply_filters('kama_breadcrumbs_pre_out', $out, $sep, $loc, $arg );    $out = sprintf( $wrappatt, $before_out . $out );                        $count_link = count(explode('$d',$out));                        $iii= 1;            foreach (explode('$d',$out) as $value) {              $replace_out .= $value.$iii++;                          }             $out =  substr($replace_out, 0, -1);                 return apply_filters('kama_breadcrumbs', $out, $sep, $loc, $arg );  }  function _page_crumbs( $post ){    $parent = $post->post_parent;    $crumbs = array();    while( $parent ){      $page = get_post( $parent );      $crumbs[] = sprintf( $this->arg->linkpatt, get_permalink($page), esc_html($page->post_title) );      $parent = $page->post_parent;    }    return implode( $this->arg->sep, array_reverse($crumbs) );  }  function _tax_crumbs( $term, $start_from = 'self' ){    $termlinks = array();    $term_id = ($start_from === 'parent') ? $term->parent : $term->term_id;    while( $term_id ){      $term       = get_term( $term_id, $term->taxonomy );      $termlinks[] = sprintf( $this->arg->linkpatt, get_term_link($term), esc_html($term->name) );      $term_id    = $term->parent;    }    if( $termlinks )      return implode( $this->arg->sep, array_reverse($termlinks) ) /*. $this->arg->sep*/;    return '';  }  // добалвяет заголовок к переданному тексту, с учетом всех опций. Добавляет разделитель в начало, если надо.  function _add_title( $add_to, $obj, $term_title = '' ){    $arg = & $this->arg; // упростим...    $title = $term_title ? $term_title : esc_html($obj->post_title); // $term_title чиститься отдельно, теги моугт быть...    $show_title = $term_title ? $arg->show_term_title : $arg->show_post_title;    // пагинация    if( $arg->pg_end ){      $link = $term_title ? get_term_link($obj) : get_permalink($obj);      $add_to .= ($add_to ? $arg->sep : '') . sprintf( $arg->linkpatt, $link, $title ) . $arg->pg_end;    }    // дополняем - ставим sep    elseif( $add_to ){      if( $show_title )        $add_to .= $arg->sep . sprintf( $arg->title_patt, $title );      elseif( $arg->last_sep )        $add_to .= $arg->sep;    }    // sep будет потом...    elseif( $show_title )      $add_to = sprintf( $arg->title_patt, $title );    return $add_to;  }}/** * Изменения: * 3.3 - новые хуки: attachment_tax_crumbs, post_tax_crumbs, term_tax_crumbs. Позволяют дополнить крошки таксономий. * 3.2 - баг с разделителем, с отключенным 'show_term_title'. Стабилизировал логику. * 3.1 - баг с esc_html() для заголовка терминов - с тегами получалось криво... * 3.0 - Обернул в класс. Добавил опции: 'title_patt', 'last_sep'. Доработал код. Добавил пагинацию для постов. * 2.5 - ADD: Опция 'show_term_title' * 2.4 - Мелкие правки кода * 2.3 - ADD: Страница записей, когда для главной установлена отделенная страница. * 2.2 - ADD: Link to post type archive on taxonomies page * 2.1 - ADD: $sep, $loc, $args params to hooks * 2.0 - ADD: в фильтр 'kama_breadcrumbs_home_after' добавлен четвертый аргумент $ptype * 1.9 - ADD: фильтр 'kama_breadcrumbs_default_loc' для изменения локализации по умолчанию * 1.8 - FIX: заметки, когда в рубрике нет записей * 1.7 - Улучшена работа с приоритетными таксономиями. *//* Регистрация 2 меню */register_nav_menus(array(	'top' => 'Верхнее',	'bottom' => 'Внизу'));/* включаем поддержку миниатюр */add_theme_support('post-thumbnails');/* Регистрация сайдбара */register_sidebar(array( // регистрируем левую колонку, этот кусок можно повторять для добавления новых областей для виджитов	'name' => 'Колонка Справа', // Название в админке	'id' => "right-sidebar", // идентификатор для вызова в шаблонах	'description' => 'Обычная колонка в сайдбаре', // Описалово в админке	'before_widget' => '<div id="%1$s" class="widget %2$s">', // разметка до вывода каждого виджета	'after_widget' => "</div>\n", // разметка после вывода каждого виджета	'before_title' => '<span class="widgettitle">', //  разметка до вывода заголовка виджета	'after_title' => "</span>\n", //  разметка после вывода заголовка виджета));/* Отключаем wp-embed */function my_deregister_scripts(){	wp_deregister_script( 'wp-embed' );}add_action( 'init', 'my_deregister_scripts' );/* правильный способ подключить стили и скрипты */function scf_theme_scripts() {	// Подключаем стили	wp_enqueue_style( 'grid-style', get_stylesheet_directory_uri().'/assets/css/grid.css' );	wp_enqueue_style( 'main-style', get_stylesheet_directory_uri().'/assets/css/styles.css' );	wp_enqueue_style( 'media-style', get_stylesheet_directory_uri().'/assets/css/media.css' );	wp_enqueue_style( 'wp-style', get_stylesheet_uri() );	// Подключаем скрипты	wp_enqueue_script( 'main-scr', get_stylesheet_directory_uri().'/assets/js/common.js', array('jquery'), '1.0.0');}add_action( 'wp_enqueue_scripts', 'scf_theme_scripts' );/*  Выводим правильный last-modified */function lastmode_headers() {	if(is_singular()) {		global $post;		$LastModified = get_the_modified_time("D, d M Y H:i:s", $post->id);		$IfModifiedSince = false;		if (isset($_ENV['HTTP_IF_MODIFIED_SINCE']))			$IfModifiedSince = strtotime(substr($_ENV['HTTP_IF_MODIFIED_SINCE'], 5));		if (isset($_SERVER['HTTP_IF_MODIFIED_SINCE']))			$IfModifiedSince = strtotime(substr($_SERVER['HTTP_IF_MODIFIED_SINCE'], 5));		if ($IfModifiedSince && $IfModifiedSince >= $LastModified_unix) {			header($_SERVER['SERVER_PROTOCOL'] . ' 304 Not Modified');			exit;		}		header('Last-Modified: '. $LastModified);	}}add_action('template_redirect', 'lastmode_headers');/* Отключаем емоджи */remove_action( 'wp_head', 'print_emoji_detection_script', 7 );remove_action( 'wp_print_styles', 'print_emoji_styles' );add_action( 'init', 'scf_register_casino_pt' ); // Использовать функцию только внутри хука initfunction scf_register_casino_pt() {	$labels = array(		'name' => 'Казино',		'singular_name' => 'Казино', // админ панель Добавить->Функцию		'add_new' => 'Добавить казино',		'add_new_item' => 'Добавить новое казино', // заголовок тега <title>		'edit_item' => 'Редактировать Казино',		'new_item' => 'Новое казино',		'all_items' => 'Все казино',		'view_item' => 'Просмотр казино на сайте',		'search_items' => 'Искать казино',		'not_found' =>  'Казино не найдено.',		'not_found_in_trash' => 'В корзине нет казино.',		'menu_name' => 'Казино' // ссылка в меню в админке	);	$args = array(		'labels' => $labels,		'public' => true,		'show_ui' => true, // показывать интерфейс в админке		'has_archive' => true,		'menu_icon' => 'dashicons-store', // иконка в меню		'menu_position' => 20, // порядок в меню		'supports' => array( 'title', 'editor', 'comments', 'author', 'thumbnail')	);	register_post_type('casino', $args);}//Регистрируем тип постов для игровых автоматовadd_action( 'init', 'scf_register_slots_pt' ); // Использовать функцию только внутри хука initfunction scf_register_slots_pt() {	$labels = array(		'name' => 'Автоматы',		'singular_name' => 'Автомат', // админ панель Добавить->Функцию		'add_new' => 'Добавить автомат',		'add_new_item' => 'Добавить новый автомат', // заголовок тега <title>		'edit_item' => 'Редактировать автомат',		'new_item' => 'Новый автомат',		'all_items' => 'Все автоматы',		'view_item' => 'Просмотр автомата на сайте',		'search_items' => 'Искать Автомат',		'not_found' =>  'Автоматов не найдено.',		'not_found_in_trash' => 'В корзине пусто',		'menu_name' => 'Автоматы' // ссылка в меню в админке	);	$args = array(		'labels' => $labels,		'public' => true,		'show_ui' => true, // показывать интерфейс в админке		'has_archive' => true,		'menu_icon' => 'dashicons-image-filter', // иконка в меню		'menu_position' => 20, // порядок в меню		'supports' => array( 'title', 'thumbnail')	);	register_post_type('slots', $args);}//Удаляем поле сайта в комменте function remove_comment_fields($fields) { 	unset($fields['url']); 	return $fields; } add_filter('comment_form_default_fields', 'remove_comment_fields');// Переносим поле текст коммента внизfunction wpb_move_comment_field_to_bottom( $fields ) {	$comment_field = $fields['comment'];	unset( $fields['comment'] );	$fields['comment'] = $comment_field;	return $fields;}add_filter( 'comment_form_fields', 'wpb_move_comment_field_to_bottom' );add_shortcode( 'screen' , 'add_screens' );function add_screens(){	$html='';	if( have_rows('screens') ):		$html.='<div class="bg-dark-purple block mb20">';		$html.='<div class="h4"><img src="'.get_stylesheet_directory_uri().'/assets/img/icon-screen.png"><span>Скриншоты из игрового автомата</span></div>';		$html.='<div class="owl-carousel screen-carousel">';		while( have_rows('screens') ): the_row();			$thumb = get_post(get_sub_field('image'));			$image_alt = get_post_meta( get_sub_field('image'), '_wp_attachment_image_alt', true);			$link = get_sub_field('image');			$html.='<div class="screen-item">';			$html.='<a href="'.wp_get_attachment_url($link).'">';			$html.='<img src="'.kama_thumb_src("w=249 &h=162", $link).'" title="'.$thumb->post_title.'" alt="'.$image_alt.'"></a></div>';		endwhile;		$html.='</div></div>';	endif;	return $html;}//начало вкладок прописка кнопокfunction rndm_button(){	if ( current_user_can('edit_posts') && current_user_can('edit_pages') ){		add_filter('mce_external_plugins', 'rndm_plugin');		add_filter('mce_buttons_2', 'rndm_register_button');	}}add_action('init', 'rndm_button');function rndm_plugin($plugin_array){	$plugin_array['rndm'] = get_bloginfo('template_url').'/assets/js/newbuttons.js';	return $plugin_array;}function rndm_register_button($buttons){	array_push($buttons, "screen");	return $buttons;}add_action('acf/init', 'my_acf_op_init');function my_acf_op_init() {    // Check function exists.    if( function_exists('acf_add_options_page') ) {        // Register options page.        $option_page = acf_add_options_page(array(            'page_title'    => __('Theme General Settings'),            'menu_title'    => __('Theme Settings'),            'menu_slug'     => 'theme-general-settings',            'capability'    => 'edit_posts',            'redirect'      => false        ));    }}add_action('acf/save_post', 'my_acf_save_post');function my_acf_save_post( $post_id ) {	if( $_SERVER['REQUEST_URI'] == '/wp-admin/admin.php?page=theme-general-settings'){		file_put_contents(get_home_path() . 'reffers.json', json_encode(get_field('refferals', 'option')));	   	}}$ref_json = json_decode(file_get_contents( 'https://' . $_SERVER['HTTP_HOST'] . '/reffers.json'));foreach ($ref_json as $ref_key => $ref_val){	if($ref_val->link == $_SERVER['REQUEST_URI']){		header('Location:' . $ref_val->name); 		exit;			}}